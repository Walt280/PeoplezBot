import math

# Returns whether cur has higher precidence than cmp.
def _is_higher(cur, cmp):
	ops = {"n":4, "p":4, "^":3, "sqrt":3, "/":2, "*":2, "+":1, "-":1, "(" : 0}
	
	return ops[cur] > ops[cmp]

# Returns whether the +/- sign is a unary or binary operator.
# See http://wcipeg.com/wiki/Shunting_yard_algorithm
def _is_unary(prev):
	return prev in "(+-*/^" or prev in ["sqrt"]

# Converts the expression exp into tokens.
def _tokenize(exp):
	tokens = []
	tmp = ""
	
	# If current character is an operator, push to output list.
	# Else, move i to tmp to accumulate.
	# (tmp accumulator is for things like numbers and function names)
	for i in exp:
		if i in "+-/*()^":
			if tmp:
				tokens.append(tmp)
				tmp = ""
			tokens.append(i)
		else:
			tmp += i
			
			#Special case of lone functions. (ex: sqrt 4)
			if tmp in ["sqrt"]:
				tokens.append(tmp)
				tmp = ""
				
	if tmp:
		tokens.append(tmp)
	return tokens

# Prepare the equation to be parsed: removes spaces and replaces unicode operators with ascii ones.
def _prep_eq(eq):
	return eq.replace(" ","").replace("−","-").replace("÷","/").replace("×","*").replace("√","sqrt")

# Check if exp is a integer or decimal number.
def _is_number(exp):
	try:
		if("." in exp):
			float(exp)
		else:
			int(exp)
		return True
	except ValueError:
		return False

# Converts exp to either a decimal or integer number.
def _to_number(exp):
	if("." in exp):
		return float(exp)
	else:
		return int(exp)

# Exception messages.
def invalid_token():
	return "Invalid token"

def unbalanced_parenthesis():
	return "Unbalanced parenthesis"
	
# Shunting yard algorithm
# Converts a string infix equation to a reverse polish notation (RPN) list of tokens.
# See https://en.wikipedia.org/wiki/Shunting-yard_algorithm
def parse_equation(equation):
	equation = _prep_eq(equation)
	stack = []
	output = []
	eq_tokens = _tokenize(equation)
	eq_tokens.reverse()
	
	if(eq_tokens[-1] == "-"):
		stack.append("n")
		eq_tokens.pop()
	
	last = ""
	while eq_tokens:
		cur = eq_tokens.pop()
			
		if(cur == "+"):
			if(_is_unary(last)):
				stack.append("p")
			else:
				if(stack and not _is_higher(cur, stack[-1])):
					output.append(stack.pop())
				stack.append(cur)
			
		elif(cur == "-"):
			if(_is_unary(last)):
				stack.append("n")
			else:
				if(stack and not _is_higher(cur, stack[-1])):
					output.append(stack.pop())
				stack.append(cur)
		# Exponentiation is special
		elif(cur == "^"):
			if(stack and cur != stack[-1] and not _is_higher(cur, stack[-1])):
				output.append(stack.pop())
			stack.append(cur)
		elif(cur == "/" or cur == "*" or cur == "sqrt"):
			if(stack and not _is_higher(cur, stack[-1])):
				output.append(stack.pop())
			stack.append(cur)
		elif(cur == "("):
			stack.append(cur)
		elif(cur == ")"):
			while(stack and stack[-1] != "("):
				output.append(stack.pop())
			#Discard left parenthesis.
			stack.pop()
		elif(_is_number(cur)):
			output.append(cur)
		else:
			raise ValueError(invalid_token())
		last = cur
	
	if("(" in stack or ")" in stack):
		raise ValueError(unbalanced_parenthesis())
		
	while stack:
		output.append(stack.pop())
	
	return output

# Evalutes the RPN list generated by parse_equation.
# See https://en.wikipedia.org/wiki/Reverse_Polish_notation#Postfix_evaluation_algorithm
def eval_equation(eq, round_digits = -1):
	stack = []
	
	for i in eq:
		if _is_number(i):
			stack.append(_to_number(i))
		else:
			result = 0
			
			if(i == "n"):
				val = stack.pop()
				result = val * -1
			elif(i == "sqrt"):
				val = stack.pop()
				result = math.sqrt(val)
			elif(i == "+"):
				right = stack.pop()
				left = stack.pop()
				result = left + right
			elif(i == "-"):
				right = stack.pop()
				left = stack.pop()
				result = left - right
			elif(i == "/"):
				right = stack.pop()
				left = stack.pop()
				result = left / right
			elif(i == "*"):
				right = stack.pop()
				left = stack.pop()
				result = left * right
			elif(i == "^"):
				right = stack.pop()
				left = stack.pop()
				result = left ** right
			else:
				raise ValueError(invalid_token())
			
			stack.append(result)
			
	if(round_digits > -1):
		return round(stack.pop(), round_digits)
	return stack.pop()
			